# Name: BaSimPL_Parser
# Description: This file holds the classes and functions which help in parsing the 'Basic Simple Programming Language'
#              (BaSimPL) using the tokens generated by the Lexxer of BaSimPL.
# References: http://jayconrod.com/posts/37/a-simple-interpreter-from-scratch-in-python-part-1
#             https://ruslanspivak.com/lsbasi-part1/
#             http://compilers.iecc.com/crenshaw/tutorfinal.pdf


import BaSimPL_Lexxer as Lex

#####################################################################################################################
#               GRAMMAR OF BaSimPL                                                                                  #
#####################################################################################################################

# SEQSTATEMENTS -> STATEMENT {STATEMENT}
# STATEMENT -> simpleSTATEMENT | compoundSTATEMENT
# simpleSTATEMENT -> assignmentSTATEMENT | procedureSTATEMENT
# compoundSTATEMENT -> ifSTATEMENT | whileSTATEMENT
# assignmentSTATEMENT -> ID ASSIGNT_OPERATOR expression SEMI_COLON
# ifSTATEMENT -> IF OPEN_BRACE expression CLOSE_BRACE SEG_OPEN SEQSTATEMENTS SEG_CLOSE {ELSE SEG_OPEN SEQSTATEMENTS SEG_CLOSE}
# whileSTATEMENT -> WHILE OPEN_BRACE expression CLOSE_BRACE SEG_OPEN SEQSTATEMENTS SEG_CLOSE
# Expression -> bterm [ OR_OPR bterm]*
# bterm -> notfactor [AND_OPR notfactor]*
# notfactor -> [NOT] bfactor
# bfactor -> INT | ID | relation
# -----------> not used --------------------expression -> relation {AND_OPR relation} | {OR_OPR relation}
# relation -> simpleExpression { relationalOperator simpleExpression}
# simpleExpression -> term { ADDSUB_OPERATOR term}
# term -> factor { MULDIV_OPERATOR factor}
# factor -> OPEN_BRACE simpleExpression CLOSE_BRACE | ID | INT | procedureSTATEMENT
# ADDSUB_OPEATOR -> ADD_OPERATOR | SUB_OPERATOR
# MULDIV_OPERATOR -> MUL_OPERATOR | DIV_OPERATOR
# relationalOperator ->  EQUALS | GREATER | LESSER | GREATEREQUAL | LESSEREQUAL | NOTEQUAL
# INT -> [0-9]{[0-9]}
# ID -> [a-zA-Z]{[a-zA-Z0-9_]}
# OPEN_BRACE -> "("
# CLOSE_BRACE -> ")"
# SEG_OPEN -> "{"
# SEG_CLOSE -> "}"
# IF -> "if"
# ELSE -> "else"
# WHILE -> "while"
# ADD_OPERATOR -> "+"
# SUB_OPERATOR -> "-"
# MUL_OPERATOR -> "*"
# DIV_OPERATOR -> "/"
# ASSIGNT_OPERATOR -> "=="
# EQUALS -> "="
# SEMI_COLON -> ";"
# IN_MODE -> "in"
# OUT_MODE -> "out"

#####################################################################################################################
#####################################################################################################################


# Name: Parser
# Description: This class is responsible for the semantic & syntactic analysis of the 'Basic Simple Programming Language'
#              This is a recursive descent parsing
class Parser(object):
    def __init__(self):
        self._position_of_token = -1
        self._List_Of_Tokens = []
        self._current_token = None
        self._Label_Counter = 0

    @property
    def List_Of_Tokens(self):
        return self._List_Of_Tokens

    @List_Of_Tokens.setter
    def List_Of_Tokens(self, value):
        self._List_Of_Tokens = value
        self._position_of_token = 0

    def get_next_token(self):
        token = Lex.Token(Lex.Defined_Token_Types.EOF, None)
        if self._position_of_token < self._List_Of_Tokens.__len__():
            token = self._List_Of_Tokens[self._position_of_token]
            self._position_of_token += 1
        # self._current_token = token
        return token

    def peek_next_token(self):
        token = Lex.Token(Lex.Defined_Token_Types.EOF, None)
        if self._position_of_token < self._List_Of_Tokens.__len__():
            token = self._List_Of_Tokens[self._position_of_token]
        return token

    def Error(self, errormsg):
        raise Exception('ERROR while parsing '+errormsg)

    def generate_labels(self, type, startOrend):
        label = type + '_'
        if startOrend == 1:
            label += 'BEGIN_'
        else:
            label += 'END_'
        label += self._Label_Counter.__str__()
        self._Label_Counter += 1

        return label

    def SimpleExpression(self):
        self.Term()
        # print 'MOV D0, D1'
        # Push it to a stack or move it to a register
        while self._current_token.Type_Of_Token == Lex.Defined_Token_Types.ADD_OPERATOR or self._current_token.Type_Of_Token == Lex.Defined_Token_Types.SUB_OPERATOR:
            if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.ADD_OPERATOR:
                self._current_token = self.get_next_token()
                self.Term()
                print 'POP D1'
                print 'POP D0'
                print 'ADD D0, D1'
            else:
                self._current_token = self.get_next_token()
                self.Term()
                print 'POP D1'
                print 'POP D0'
                print 'SUB D0, D1'
            print 'PUSH D0'

        return

    def SeqStatements(self):

        while self._current_token.Type_Of_Token != Lex.Defined_Token_Types.EOF:
            self.Statements()

        return

    def Statements(self):
        if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.IF or self._current_token.Type_Of_Token == Lex.Defined_Token_Types.WHILE:
            self.CompoundStatement()
        else:
            self.SimpleStatement()

        return

    def SimpleStatement(self):
        next_token = self.peek_next_token()
        if next_token.Type_Of_Token == Lex.Defined_Token_Types.OPEN_BRACE:
            function_call = self._current_token.Value_Of_Token
            while self._current_token != Lex.Defined_Token_Types.CLOSE_BRACE:
                self._current_token = self.get_next_token()
            self._current_token = self.get_next_token()
            print 'CALL ' + function_call
        else:
            self.AssignmentStatement()
        return

    def CompoundStatement(self):
        if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.IF:
            self.IfStatement()
        else:
            self.WhileStatement()
        return

    def AssignmentStatement(self):
        # ID = expression ;

        if self._current_token is not None and self._current_token.Type_Of_Token == Lex.Defined_Token_Types.IDENTIFIER:
            variable = self._current_token.Value_Of_Token
            self._current_token = self.get_next_token()
            if self._current_token is not None and self._current_token.Type_Of_Token == Lex.Defined_Token_Types.ASSIGNMENT_OPERATOR:
                self._current_token = self.get_next_token()
                self.Expression()
                if self._current_token is not None and self._current_token.Type_Of_Token == Lex.Defined_Token_Types.SEMICOLON:
                    print 'LEA A0, ' + variable + '(PC)'
                    print 'POP D0'
                    print 'MOV (A0), D0'
                    self._current_token = self.get_next_token()
                else:
                    errormsg = 'Expected a Semicolon ; but got some other token'
                    self.Error(errormsg)
            else:
                errormsg = 'Expected an assignment operator'
                self.Error(errormsg)
        else:
            errormsg = 'Expected an identifier'
            self.Error(errormsg)

        return

    def IfStatement(self):
        self._current_token = self.get_next_token()
        if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.OPEN_BRACE:
            endIflabel = self.generate_labels('IF', 0)
            endElselable = endIflabel
            self._current_token = self.get_next_token()
            self.Expression()
            print 'POP D0'
            print 'BEQ '+endIflabel
            if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.CLOSE_BRACE:
                self._current_token = self.get_next_token()
                if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.SEG_OPEN:
                    self._current_token = self.get_next_token()
                    while self._current_token.Type_Of_Token != Lex.Defined_Token_Types.SEG_CLOSE:
                        self.Statements()
                    self._current_token = self.get_next_token()

                    if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.ELSE:
                        self._current_token = self.get_next_token()
                        if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.SEG_OPEN:
                            endElselable = self.generate_labels('ELSE', 0)
                            print 'JMP ' + endIflabel
                            print endIflabel + ':'
                            self._current_token = self.get_next_token()
                            while self._current_token.Type_Of_Token != Lex.Defined_Token_Types.SEG_CLOSE:
                                self.Statements()
                            self._current_token = self.get_next_token()
                        else:
                            errorMsg = 'Expected }'
                            self.Error(errorMsg)

                    print endElselable + ':'
                else:
                    errorMsg = 'Expected {'
                    self.Error(errorMsg)
            else:
                errorMsg = 'Expected )'
                self.Error(errorMsg)
        else:
            errorMsg = 'Expected ('
            self.Error(errorMsg)

        return

    def WhileStatement(self):
        self._current_token = self.get_next_token()
        if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.OPEN_BRACE:
            endWhileLabel = self.generate_labels('WHILE', 0)
            startWhileLabel = self.generate_labels('WHILE', 1)
            self._current_token = self.get_next_token()
            print startWhileLabel + ':'
            self.Expression()
            print 'POP D0'
            print 'BEQ ' + endWhileLabel
            if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.CLOSE_BRACE:
                self._current_token = self.get_next_token()
                if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.SEG_OPEN:
                    self._current_token = self.get_next_token()
                    while self._current_token.Type_Of_Token != Lex.Defined_Token_Types.SEG_CLOSE:
                        self.Statements()
                    self._current_token = self.get_next_token()
                    print 'JMP ' + startWhileLabel
                    print endWhileLabel + ':'
                else:
                    errorMsg = 'Expected {'
                    self.Error(errorMsg)
            else:
                errorMsg = 'Expected )'
                self.Error(errorMsg)
        else:
            errorMsg = 'Expected ('
            self.Error(errorMsg)
        return

    def Expression(self):
        self.BTerm()
        while self._current_token.Type_Of_Token == Lex.Defined_Token_Types.LOG_OR_OPERATOR:
            self._current_token = self.get_next_token()
            self.BTerm()
            print 'POP D1'
            print 'POP D0'
            print 'OR D0, D1'
            print 'PUSH D0'

        return

    def Relation(self):
        self.SimpleExpression()
        while self._current_token.Type_Of_Token == Lex.Defined_Token_Types.GREATEREQUAL_OPERATOR or self._current_token.Type_Of_Token == Lex.Defined_Token_Types.GREATERTHAN_OPERATOR or \
            self._current_token.Type_Of_Token == Lex.Defined_Token_Types.LESSERTHAN_OPERATOR or self._current_token.Type_Of_Token == Lex.Defined_Token_Types.LESSEREQUAL_OPERATOR or \
            self._current_token.Type_Of_Token == Lex.Defined_Token_Types.EQUALS_OPERATOR or self._current_token.Type_Of_Token == Lex.Defined_Token_Types.NOTEQUAL_OPERATOR:
            relop = self._current_token.Type_Of_Token
            self._current_token = self.get_next_token()
            self.Expression()
            print 'POP D1'
            print 'POP D0'
            if relop == Lex.Defined_Token_Types.NOTEQUAL_OPERATOR:
                print 'CNE D0, D1'
            elif relop == Lex.Defined_Token_Types.EQUALS_OPERATOR:
                print 'CEQ D0,D1'
            elif relop == Lex.Defined_Token_Types.GREATERTHAN_OPERATOR:
                print 'CGT D0,D1'
            elif relop == Lex.Defined_Token_Types.GREATEREQUAL_OPERATOR:
                print 'CGE D0,D1'
            elif relop == Lex.Defined_Token_Types.LESSEREQUAL_OPERATOR:
                print 'CLE D0,D1'
            else:
                print 'CLT D0,D1'
            print 'PUSH D0'
        return

    def BTerm(self):
        self.NotFactor()
        while self._current_token.Type_Of_Token == Lex.Defined_Token_Types.LOG_AND_OPERATOR:
            self._current_token = self.get_next_token()
            self.NotFactor()
            print 'POP D1'
            print 'POP D0'
            print 'AND D0, D1'
            print 'PUSH D0'
        return

    def NotFactor(self):
        # As of now it is directly calling next step. Future It will do the logical not operation.
        self.BFactor()
        return

    def BFactor(self):
        self.Relation()
        return

    def Term(self):
        self.Factor()
        #print 'MOV D0, D1'
        while self._current_token.Type_Of_Token == Lex.Defined_Token_Types.MUL_OPERATOR or self._current_token.Type_Of_Token == Lex.Defined_Token_Types.DIV_OPERATOR:
            if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.MUL_OPERATOR:
                self._current_token = self.get_next_token()
                self.Factor()
                print 'POP D1'
                print 'POP D0'
                print 'MUL D0, D1'

            else:
                self._current_token = self.get_next_token()
                self.Factor()
                print 'POP D1'
                print 'POP D0'
                print 'DIV D0, D1'
            print 'PUSH D0'

        return

    def Factor(self):
        # Token should be either an integer or an identifier
        if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.INT:
            # This is a constant
            #movi A, value
            print 'MOVI D0, ' + self._current_token.Value_Of_Token
            print 'PUSH D0'
            self._current_token = self.get_next_token()
        elif self._current_token.Type_Of_Token == Lex.Defined_Token_Types.IDENTIFIER:
            next_token = self.peek_next_token()
            if next_token.Type_Of_Token == Lex.Defined_Token_Types.OPEN_BRACE:
                # print 'PUSH $RA'
                function_call = self._current_token.Value_Of_Token
                while self._current_token.Type_Of_Token != Lex.Defined_Token_Types.CLOSE_BRACE:
                    self._current_token = self.get_next_token()
                print 'CALL ' + function_call
                print 'PUSH D0'                                                                 #Return Value
                self._current_token = self.get_next_token()
            else:
                print 'LEA A0, ' + self._current_token.Value_Of_Token + '(PC)'
                print 'MOV D0, (A0)'
                print 'PUSH D0'
                self._current_token = self.get_next_token()
        elif self._current_token.Type_Of_Token == Lex.Defined_Token_Types.OPEN_BRACE:
            self._current_token = self.get_next_token()
            self.Expression()
            if self._current_token.Type_Of_Token == Lex.Defined_Token_Types.CLOSE_BRACE:
                self._current_token = self.get_next_token()
            else:
                errormsg = 'Expected a closing bracket'
                self.Error(errormsg)
        else:
            errormsg = 'Exepected a value or an identifier'
            self.Error(errormsg)
        return

    def ParseIt(self):
        # self.SeqStatements()
        self._current_token = self.get_next_token()
        self.SeqStatements()
        # self.AssignmentStatement()
        # self.SimpleExpression()
        return





